!MainRule       = TranslationUnit;
!SpaceMethod    = Whitespace;
!SpaceDirection = Both;

# BasicCharacterSet
BasicCharacterSet: '[ \t\v\f\na-zA-Z0-9_{}\[\]#()<>%:;.?*+-\/^&|~!=,\\"\']';

# Keywords
TypedefName:    Identifier | SimpleTemplateId;
NamespaceName:  Identifier | NamespaceAlias;
NamespaceAlias: Identifier;
ClassName:      Identifier | SimpleTemplateId;
EnumName:       Identifier;
TemplateName:   Identifier;

# Lexical Conventions
HexQuad:                         HexadecimalDigit{4};
UniversalCharacterName:          '\\[uU]' HexQuad;
PreprocessingToken:              HeaderName;
                                 ImportKeyword;
                                 ModuleKeyword;
                                 ExportKeyword;
                                 Identifier;
                                 PPNumber;
                                 CharacterLiteral;
                                 UserDefinedCharacterLiteral;
                                 StringLiteral;
                                 UserDefinedStringLiteral;
                                 PreprocessingOpOrPunc;
                                 '[a-zA-Z0-9_{}\[\]#()<>%:;.?*+-\/^&|~!=,\\"\']';
Token:                           Identifier;
                                 Keyword;
                                 Literal;
                                 OperatorOrPunctuator;
HeaderName:                      "<" HCharSequence ">";
                                 "\"" QCharSequence "\"";
HCharSequence:                   HChar+;
HChar:                           '[ \t\v\fa-zA-Z0-9_{}\[\]#()<%:;.?*+-\/^&|~!=,\\"\']';
QCharSequence:                   QChar+;
QChar:                           '[ \t\v\fa-zA-Z0-9_{}\[\]#()<>%:;.?*+-\/^&|~!=,\\\']';
PPNumber:                        "."? Digit;
                                 PPNumber (Digit | IdentifierNonDigit);
                                 PPNumber "'" (Digit | NonDigit);
                                 PPNumber ("e" | "E" | "p" | "P") Sign;
                                 PPNumber ".";
Identifier:                      IdentifierNonDigit (Digit | IdentifierNonDigit)*;
IdentifierNonDigit:              NonDigit | UniversalCharacterName;
NonDigit:                        '[a-zA-Z_]';
Digit:                           '[0-9]';
Keyword:                         "alignas";
                                 "alignof";
                                 "asm";
                                 "auto";
                                 "bool";
                                 "break";
                                 "case";
                                 "catch";
                                 "char";
                                 "char8_t";
                                 "char16_t";
                                 "char32_t";
                                 "class";
                                 "concept";
                                 "const";
                                 "consteval";
                                 "constexpr";
                                 "constinit";
                                 "const_cast";
                                 "continue";
                                 "co_await";
                                 "co_return";
                                 "co_yield";
                                 "decltype";
                                 "default";
                                 "delete";
                                 "do";
                                 "double";
                                 "dynamic_cast";
                                 "else";
                                 "enum";
                                 "explicit";
                                 "export";
                                 "extern";
                                 "false";
                                 "float";
                                 "for";
                                 "friend";
                                 "goto";
                                 "if";
                                 "inline";
                                 "int";
                                 "long";
                                 "mutable";
                                 "namespace";
                                 "new";
                                 "noexcept";
                                 "nullptr";
                                 "operator";
                                 "private";
                                 "protected";
                                 "public";
                                 "register";
                                 "reinterpret_cast";
                                 "requires";
                                 "return";
                                 "short";
                                 "signed";
                                 "sizeof";
                                 "static";
                                 "static_assert";
                                 "static_cast";
                                 "struct";
                                 "switch";
                                 "template";
                                 "this";
                                 "thread_local";
                                 "throw";
                                 "true";
                                 "try";
                                 "typedef";
                                 "typeid";
                                 "typename";
                                 "union";
                                 "unsigned";
                                 "using";
                                 "virtual";
                                 "void";
                                 "volatile";
                                 "wchar_t";
                                 "while";
                                 ImportKeyword;
                                 ModuleKeyword;
                                 ExportKeyword;
PreprocessingOpOrPunc:           PreprocessingOperator | OperatorOrPunctuator;
PreprocessingOperator:           "#" | "##" | "%:" | "%:%:";
OperatorOrPunctuator:            "{" | "}" | "[" | "]" | "(" | ")" | "<:" | ":>" | "<%" | "%>" | ";" | ":" | "..." | "?" | "::" | "." | ".*" | "->" | "->*" | "~" | "!" | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" |  "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "==" | "!=" | "<" | ">" | "<=" | ">=" | "<=>" | "&&" | "||" | "<<" | ">>" | "<<=" | ">>=" | "++" | "--" | "," | "and" | "or" | "xor" | "not" | "bitand" | "bitor" | "compl" | "and_eq" | "or_eq" | "xor_eq" | "not_eq";
Literal:                         IntegerLiteral;
                                 CharacterLiteral;
                                 FloatingPointLiteral;
                                 StringLiteral;
                                 BooleanLiteral;
                                 PointerLiteral;
                                 UserDefinedLiteral;
IntegerLiteral:                  BinaryLiteral IntegerSuffix?;
                                 OctalLitearl IntegerSuffix?;
                                 DecimalLiteral IntegerSuffix?;
                                 HexadecimalLiteral INtegerSuffix?;
BinaryLiteral:                   '0[bB]' BinaryDigit ("'"? BinaryDigit)*;
OctalLiteral:                    "0" ("'"? OctalDigit)*;
DecimalLiteral:                  NonZeroDigit ("'"? Digit)*;
HexadecimalLiteral:              HexadecimalPrefix HexadecimalDigitSequence;
BinaryDigit:                     "0" | "1";
OctalDigit:                      '[0-7]';
NonZeroDigit:                    '[1-9]';
HexadecimalPrefix:               '0[xX]';
HexadecimalDigitSequence:        HexadecimalDigit ("'"? HexadecimalDigit)*;
HexadecimalDigit:                '[0-9a-fA-F]';
IntegerSuffix:                   "u" | "U";
LongSuffix:                      "l" | "L";
LongLongSuffix:                  "ll" | "LL";
CharacterLiteral:                EncodingPrefix? "'" CCharSequence "'";
EncodingPrefix:                  "u8" | "u" | "U" | "L";
CCharSequence:                   CChar+;
CChar:                           '[ \t\v\fa-zA-Z0-9_{}\[\]#()<>%:;.?*+-\/^&|~!=,"]';
                                 EscapeSequence;
                                 UniversalCharacterName;
EscapeSequence:                  SimpleEscapeSequence;
                                 OctalEscapeSequence;
                                 HexadecimalEscapeSequence;
SimpleEscapeSequence:            "\\'" | "\\\"" | "\\?" | "\\\\" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v";
OctalEscapeSequence:             "\\" OctalDigit{1,3};
HexadecimalEscapeSequence:       "\\x" HexadecimalDigit+;
FloatingPointLiteral:            DecimalFloatingPointLiteral;
                                 HexadecimalFloatingPointLiteral;
DecimalFloatingPointLiteral:     FractionalConstant ExponentPart? FloatingPointSuffix?;
                                 DigitSequence ExponentPart FloatingPointSuffix?;
HexadecimalFloatingPointLiteral: HexadecimalPrefix HexadecimalFractionalConstant BinaryExponentPart FloatingPointSuffix?;
                                 HexadecimalPrefix HexadecimalDigitSequence BinaryExponentPart FloatingPointSuffix?;
FractionalConstant:              DigitSequence? "." DigitSequence;
                                 DigitSequence ".";
HexadecimalFractionalConstant:   HexadecimalDigitSequence? "." HexadecimalDigitSequence;
                                 HexadecimalDigitSequence ".";
ExponentPart:                    ("e" | "E") Sign? DigitSequence;
BinaryExponentPart:              ("p" | "P") Sign? DigitSequence;
Sign:                            "+" | "-";
DigitSequence:                   Digit ("'"? Digit)*;
FloatingPointSuffix:             "f" | "l" | "F" | "L";
StringLiteral:                   EncodingPrefix? "\"" SCharSequence? "\"";
                                 EncodingPrefix? "R" RawString;
SCharSequence:                   SChar+;
SChar:                           '[ \t\v\fa-zA-Z0-9_{}\[\]#()<>%:;.?*+-\/^&|~!=,\']';
                                 EscapeSequence;
                                 UniversalCharacterName;
RawString:                       "\"" (<RawStringInitiator>: DCharSequence?) "(" RCharSequence? ")" \RawStringInitiator "\"";
RCharSequence:                   RChar+;
RChar:                           '[ \t\v\f\na-zA-Z0-9_{}\[\]#(<>%:;.?*+-\/^&|~!=,\\"\']';
                                 ")" !(\RawStringInitiator "\"");
DCharSequence:                   DChar+;
DChar:                           '[a-zA-Z0-9_{}\[\]#<>%:;.?*+-\/^&|~!=,"\']';
BooleanLiteral:                  "false" | "true";
PointerLiteral:                  "nullptr";
UserDefinedLiteral:              UserDefinedIntegerLiteral;
                                 UserDefinedFloatingPointLiteral;
                                 UserDefinedStringLiteral;
                                 UserDefinedCharacterLiteral;
UserDefinedIntegerLiteral:       (DecimalLiteral | OctalLiteral | HexadecimalLiteral | BinaryLiteral) UDSuffix;
UserDefinedFloatingPointLiteral: FractionalConstant ExponentPart? UDSuffix;
                                 DigitSequence ExponentPart UDSuffix;
                                 HexadecimalPrefix HexadecimalFractionalConstant BinaryExponentPart UDSuffix;
                                 HexadecimalPrefix HexadecimalDigitSequence BinaryExponentPart UDSuffix;
UserDefinedStringLiteral:        StringLiteral UDSuffix;
UserDefinedCharacterLiteral:     CharacterLiteral UDSuffix;
UDSuffix:                        Identifier;

# Basics
TranslationUnit: DeclarationSeq?;
                 GlobalModuleFragment,? ModuleDeclaration, DeclarationSeq,? PrivateModuleFragment?;

# Expressions
PrimaryExpression:        Literal;
                          "this";
                          "(", Expression, ")";
                          IdExpression;
                          LambdaExpression;
                          FoldExpression;
                          RequiresExpression;
IdExpression:             UnqualifiedId;
                          QualifiedId;
UnqualifiedId:            Identifier;
                          OperatorFunctionId;
                          ConversionFunctionId;
                          LiteralOperatorId;
                          "~", TypeName;
                          "~", DecltypeSpecifier;
                          TemplateId;
QualifiedId:              NestedNameSpecifier "template",? UnqualifiedId;
NestedNameSpecifier:      "::";
                          TypeName, "::";
                          NamespaceName, "::";
                          DecltypeSpecifier, "::";
                          NestedNameSpecifier, Identifier, "::";
                          NestedNameSpecifier, "template",? SimpleTemplateId, "::";
LambdaExpression:         LambdaIntroducer, LambdaDeclarator,? CompoundStatement;
                          LambdaIntroducer, "<", TemplateParameterList, ">", RequiresClause,? LambdaDeclarator,? CompoundStatement;
LambdaIntroducer:         "[", LambdaCapture,? "]";
LambdaDeclarator:         "(", ParameterDeclarationClause, ")", DeclSpecifierSeq,? NoexceptSpecifier,? AttributeSpecifierSeq,? TrailingReturnType,? RequiresClause?;
LambdaCapture:            CaptureDefault;
                          CaptureList;
                          CaptureDefault, ",", CaptureList;
CaptureDefault:           "&";
                          "=";
CaptureList:              Capture, (",", Capture)*;
Capture:                  SimpleCapture;
                          InitCapture;
SimpleCapture:            Identifier, "..."?;
                          "&", Identifier, "..."?;
                          "this";
                          "*", "this";
InitCapture:              "...",? Identifier, Initializer;
                          "&", "...",? Identifier, Initializer;
FoldExpression:           "(", CastExpression, FoldOperator, "...", ")";
                          "(", "...", FoldOperator, CastExpression, ")";
                          "(", CastExpression, FoldOperator, "...", FoldOperator, CastExpression ")";
FoldOperator:             '[+-*\/%\^&|<>,=]|<<|>>|\+=|\-=|\*=|\/=|%=|\^=|&=|<<=|>>=|==|!=|<=|>=|&&|\|\||\.\*|\->\*';
RequiresExpression:       "requires", RequirementParameterList,? RequirementBody;
RequirementParameterList: "(", ParameterDeclarationClause,? ")";
RequirementBody:          "{", RequirementSeq, "}";
RequirementSeq:           Requirement+;
Requirement:              SimpleRequirement;
                          TypeRequirement;
                          CompoundRequirement;
                          NestedRequirement;
SimpleRequirement:        Expression, ";";
TypeRequirement:          "typename", NestedNameSpecifier,? TypeName, ";";
CompoundRequirement:      "{", Expression, "}", "noexcept",? ReturnTypeRequirement,? ";";
ReturnTypeRequirement:    "->", TypeConstraint;
NestedRequirement:        "requires", ConstraintExpression, ";";
PostfixExpression:        PrimaryExpression;
                          PostfixExpression, "[", ExprOrBracedInitList, "]";
                          (PostfixExpression | SimpleTypeSpecifier | TypenameSpecifier), "(", ExpressionList,? ")";
                          (SimpleTypeSpecifier | TypenameSpecifier) BracedInitList;
                          PostfixExpression, ("." | "->"), "template",? IdExpression;
                          PostfixExpression, ("++" | "--");
                          ("dynamic_cast" | "static_cast" | "reinterpret_cast" | "const_cast"), "<", TypeId, ">", "(", Expression, ")";
                          "typeid", "(", (Expression | TypeId), ")";
ExpressionList:           InitializerList;
UnaryExpression:          PostfixExpression;
                          UnaryOperator, CastExpression;
                          "++", CastExpression;
                          "--", CastExpression;
                          AwaitExpression;
                          "sizeof", UnaryExpression;
                          "sizeof", "(", TypeId, ")";
                          "sizeof", "...", "(", Identifier, ")";
                          "alignof", "(", TypeId, ")";
                          NoexceptExpression;
                          NewExpression;
                          DeleteExpression;
UnaryOperator:            '[*&+-!~]';
AwaitExpression:          "co_await", CastExpression;
NoexceptExpression:       "noexcept", "(", Expression, ")";
NewExpression:            "::",? "new", NewPlacement,? (NewTypeId | "(", TypeId, ")"), NewInitializer?;
NewPlacement:             "(", ExpressionList, ")";
NewTypeId:                TypeSpecifierSeq, NewDeclarator?;
NewDeclarator:            PtrOperator, NewDeclarator?;
                          NoptrNewDeclarator;
NoptrNewDeclarator:       "[", Expression,? "]", AttributeSpecifierSeq?;
                          NoptrNewDeclarator, "[", ConstantExpression, "]", AttributeSpecifierSeq?;
NewInitializer:           "(", ExpressionList,? ")";
                          BracedInitList;
DeleteExpression:         "::",? "delete", ("[", "]"),? CastExpression;
CastExpression:           ("(", TypeId, ")"),* UnaryExpression;
PmExpression:             CastExpression;
                          PmExpression, (".*" | "->*"), CastExpression;
MultiplicativeExpression: PmExpression;
                          MultiplicativeExpression, ("*" | "/" | "%"), PmExpression;
AdditiveExpression:       MultiplicativeExpression;
                          AdditiveExpression, ("+" | "-"), MultiplicativeExpression;
ShiftExpression:          AdditiveExpression;
                          ShiftExpression, ("<<" | ">>"), AdditiveExpression;
CompareExpression:        ShiftExpression;
                          CompareExpression, "<=>", ShiftExpression;
RelationalExpression:     CompareExpression;
                          RelationalExpression, ("<", ">", "<=", ">="), CompareExpression;
EqualityExpression:       RelationalExpression;
                          EqualityExpression, ("==", "!="), EqualityExpression;
AndExpression:            EqualityExpression;
                          AndExpression, "&", EqualityExpression;
ExcluseOrExpression:      AndExpression;
                          ExclusiveOrExpression, "^", AndExpression;
InclusiveOrExpression:    ExclusiveOrExpression;
                          InclusiveOrExpression, "|", ExclusiveOrExpression;
LogicalAndExpression:     InclusiveOrExpression;
                          LogicalAndExpression, "&&", InclusiveOrExpression;
LogicalOrExpression:      LogicalAndExpression;
                          LogicalOrExpression, "||", LogicalAndExpression;
ConditionalExpression:    LogicalOrExpression;
                          LogicalOrExpression, "?", Expression, ":", AssignmentExpression;
YieldExpression:          "co_yield", (AssignmentExpression | BracedInitList);
ThrowExpression:          "throw", AssignmentExpression?;
AssignmentExpression:     ConditionalExpression;
                          YieldExpression;
                          ThrowExpression;
                          LogicalOrExpression, AssignmentOperator, InitializerClause;
AssignmentOperator:       "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>=" | "<<=" | "&=" | "^=" | "|=";
Expression:               AssignmentExpression, (",", AssignmentExpression)*;
ConstantExpression:       ConditionalExpression;

# Statements
Statement:                LabeledStatement;
                          AttributeSpecifierSeq,? (ExpressionStatement | CompoundStatement | SelectionStatement | IterationStatement | JumpStatement);
                          DeclarationStatement;
                          AttributeSpecifierSeq,? TryBlock;
InitStatement:            ExpressionStatement;
                          SimpleDeclaration;
Condition:                Expression;
                          AttributeSpecifierSeq,? DeclSpecifierSeq, Declarator, BraceOrEqualInitializer;
LabeledStatement:         AttributeSpecifierSeq,? Identifier, ":", Statement;
                          AttributeSpecifierSeq,? "case", ConstantExpression, ":", Statement;
                          AttributeSpecifierSeq,? "default", ":", Statement;
ExpressionStatement:      Expression,? ";";
CompoundStatement:        "{", StatementSeq,? "}";
StatementSeq:             Statement+;
SelectionStatement:       "if", "constexpr",? "(", InitStatement,? Condition, ")", Statement;
                          "if", "constexpr",? "(", InitStatement,? Condition, ")", Statement, "else", Statement;
                          "switch", "(", InitStatement,? Condition, ")", Statement;
IterationStatement:       "while", "(", Condition, ")", Statement;
                          "do", Statement, "while", "(", Expression, ")", Statement;
                          "for", "(", InitStatement, Condition,? ";" Expression,? ")", Statement;
                          "for", "(", InitStatement,? ForRangeDeclaration, ":", ForRangeInitializer, ")", Statement;
ForRangeDeclaration:      AttributeSpecifierSeq,? DeclSpecifierSeq, Declarator;
                          AttributeSpecifierSeq,? DeclSpecifierSeq, RefQualifier,? "[", IdentifierList, "]";
ForRangeInitializer:      ExprOrBracedInitList;
JumpStatement:            "break", ";";
                          "continue", ";";
                          "return", ExprOrBracedInitList,? ";";
                          CoroutineReturnStatement;
                          "goto", Identifier, ";";
CoroutineReturnStatement: "co_return", ExprOrBracedInitList,? ";";
DeclarationStatement:     BlockDeclaration;

# Declarations
DeclarationSeq:                Declaration+;
Declaration:                   BlockDeclaration;
                               NoDeclspecFunctionDeclaration;
                               FunctionDefinition;
                               TemplateDeclaration;
                               DeductionGuide;
                               ExplicitInstatiation;
                               ExplicitSpeclization;
                               ExportDeclaration;
                               LinkageSpecification;
                               NamespaceDefinition;
                               EmptyDeclaration;
                               AttributeDeclaration;
                               ModuleImportDeclaration;
BlockDeclaration:              SimpleDeclaration;
                               AsmDeclaration;
                               NamespaceAliasDefinition;
                               UsingDeclaration;
                               UsingEnumDeclaration;
                               UsingDirective;
                               Static_assertDeclaration;
                               AliasDeclaration;
                               OpaqueEnumDeclaration;
NoDeclspecFunctionDeclaration: AttributeSpecifierSeq,? Declarator, ";";
AliasDeclaration:              "using", Identifier, AttributeSpecifierSeq,? "=", DefiningTypeId, ";";
SimpleDeclaration:             DeclSpecifierSeq, InitDeclaratorList,? ";";
                               AttributeSpecifierSeq, DeclSpecifierSeq, InitDeclaratorList, ";";
                               AttributeSpecifierSeq,? DeclSpecifierSeq, RefQualifier,? "[", IdentifierList, "]", Initializer, ";";
Static_assertDeclaration:      "static_assert", "(", ConstantExpression, ")", ";";
                               "static_assert", "(", ConstantExpression, ",", StringLiteral, ")", ";";
EmptyDeclaration:              ";";
DeclSpecifier:                 StorageClassSpecifier;
                               DefiningTypeSpecifier;
                               FunctinoSpecifier;
                               "friend";
                               "typedef";
                               "constexpr";
                               "consteval";
                               "constinit";
                               "inline";
DeclSpecifierSeq:              (DeclSpecifier | DeclSpecifier, AttributeSpecifierSeq),+;
StorageClassSpecifier:         "static";
                               "thread_local";
                               "extern";
                               "mutable";
FunctionSpecifier:             "virtual";
                               ExplicitSpecifier;
ExplicitSpecifier:             "explicit", "(", ConstantExpression, ")";
                               "explicit";
TypedefName:                   Identifier;
                               SimpleTemplateId;
TypeSpecifier:                 SimpleTypeSpecifier;
                               ElaboratedTypeSpecifier;
                               TypenameSpecifier;
                               CVQualifier;
TypeSpecifierSeq:              (TypeSpecifier | TypeSpecifier, AttributeSpecifierSeq),+;
DefiningTypeSpecifier:         TypeSpecifier;
                               ClassSpecifier;
                               EnumSpecifier;
DefiningTypeSpecifierSeq:      (DefiningTypeSpecifier | DefiningTypeSpecifier, AttributeSpecifierSeq),+;
SimpleTypeSpecifier:           NestedNameSpecifier,? TypeName;
                               NestedNameSpecifier, "template", SimpleTemplateId;
                               DecltypeSpecifier;
                               PlaceholderTypeSpecifier;
                               NestedNameSpecifier,? TemplateName;
                               "char";
                               "char8_t";
                               "char16_t";
                               "wchar_t";
                               "bool";
                               "short";
                               "int";
                               "long";
                               "signed";
                               "unsigned";
                               "float";
                               "double";
                               "void";
TypeName:                      ClassName;
                               EnumName;
                               TypedefName;
ElaboratedTypeSpecifier:       ClassKey, AttributeSpecifierSeq,? NestedNameSpecifier,? Identifier;
                               ClassKey, SimpleTemplateId;
                               ClassKey, NestedNameSpecifier, "template",? SimpleTemplateId;
                               ElaboratedEnumSpecifier;
ElaboratedEnumSpecifier:       "enum", NestedNameSpecifier,? Identifier;
DecltypeSpecifier:             "decltype", "(", Expression, ")";
PlaceholderTypeSpecifier:      TypeConstraint? "auto";
                               TypeConstraint? "decltype", "(", "auto", ")";
InitDeclaratorList:            InitDeclarator, (",", InitDeclarator),*;
InitDeclarator:                Declarator, Initializer?;
                               Declarator, RequiresClause;
Declarator:                    PtrDeclarator;
                               NoptrDeclarator, ParametersAndQualifiers, TrailingReturnType;
PtrDeclarator:                 NoptrDeclarator;
                               PtrOperator, PtrDeclarator;
NoptrDeclarator:               DeclaratorId, AttributeSpecifierSeq?;
                               NoptrDeclarator, ParametersAndQualifiers;
                               NoptrDeclarator, "[", ConstantExpression,? "]", AttributeSpecifierSeq?;
                               "(", PtrDeclarator, ")";
ParametersAndQualifiers:       "(", ParameterDeclarationClause, ")", CVQualifierSeq,? RefQualifier,? NoexceptSpecifier,? AttributeSpecifierSeq?;
TrailingReturnType:            "->", TypeId;
PtrOperator:                   "*", AttributeSpecifierSeq,? CVQualifierSeq?;
                               "&", AttributeSpecifierSeq?;
                               "&&", AttributeSpecifierSeq?;
                               NestedNamedSpecifier, "*", AttributeSpecifierSeq,? CVQualifierSeq?;
CVQualifierSeq:                CVQualifier+;
CVQualifier:                   "const";
                               "volatile";
RefQualifier:                  "&";
                               "&&";
DeclaratorId:                  "...",? IdExpression;
TypeId:                        TypeSpecifierSeq, AbstractDeclarator?;
DefiningTypeId:                DefiningTypeSpecifierSeq, AbstractDeclarator?;
AbstractDeclarator:            PtrAbstractDeclarator;
                               NoptrAbstractDeclarator,? ParametersAndQualifiers, TrailingReturnType;
                               AbstractPackDeclarator;
PtrAbstractDeclarator:         (PtrOperator | NoptrAbstractDeclarator),+;
NoptrAbstractDeclarator:       NoPtrAbstractDeclarator,? ParametersAndQualifiers;
                               NoPtrAbstractDeclarator,? "[", ConstantExpression, "]", AttributeSpecifierSeq?;
                               "(", PtrAbstractDeclarator, ")";
AbstractPackDeclarator:        (PtrOperator | NoptrAbstractPackDeclarator),+;
NoptrAbstractPackDeclarator:   NoptrAbstractPackDeclarator, ParametersAndQualifiers;
                               NoptrAbstractPackDeclarator, "[", ConstantExpression,? "]", AttributeSpecifierSeq?;
                               "...";
ParameterDeclarationClause:    ParameterDeclarationList,? "..."?;
                               ParameterDeclarationList, ",", "...";
ParameterDeclarationList:      ParameterDeclaration, (",", ParameterDeclaration),*;
ParameterDeclaration:          AttributeSpecifierSeq,? DeclSpecifierSeq, Declarator;
                               AttributeSpecifierSeq,? DeclSpecifierSeq, Declarator, "=", InitializerClause;
                               AttributeSpecifierSeq,? DeclSpecifierSeq, AbstractDeclarator?;
                               AttributeSpecifierSeq,? DeclSpecifierSeq, AbstractDeclarator,? "=", InitializerClause;
Initializer:                   BraceOrEqualInitializer;
                               "(", ExpressionList, ")";
BraceOrEqualInitializer:       "=", InitializerClause;
                               BracedInitList;
InitializerClause:             AssignmentExpression;
                               BracedInitList;
BracedInitList:                "{", InitializerList, ",",? "}";
                               "{", DesignatedInitializerList, ",",? "}";
                               "{", "}";
InitializerList:               InitializerClause, "...",? (",", InitializerClause, "...",?),*;
DesignatedInitializerList:     DesignatedInitializerClause, (",", DesignatedInitializerClause),*;
DesignatedInitializerClause:   Designator BraceOrEqualInitializer;
Designator:                    ".", Identifier;
ExprOrBracedInitList:          Expression;
                               BracedInitList;
FunctionDefinition:            AttributeSpecifierSeq,? DeclSpecifierSeq,? Declarator, VirtSpecifierSeq,? FunctionBody;
                               AttributeSpecifierSeq,? DeclSpecifierSeq,? Declarator, RequiresClause, FunctionBody;
FunctionBody:                  CTorInitializer,? CompoundStatement;
                               FunctionTryBlock;
                               "=", "default", ";";
                               "=", "delete", ";";
EnumName:                      Identifier;
EnumSpecifier:                 EnumHead, "{", EnumeratorList,? "}";
                               EnumHead, "{", EnumeratorList, ",", "}";
EnumHead:                      EnumKey, AttributeSpecifierSeq,? EnumHeadName,? EnumBase,?;
EnumHeadName:                  NestedNameSpecifier,? Identifier;
OpaqueEnumDeclaration:         EnumKey, AttributeSpecifierSeq,? EnumHeadName, EnumBase,? ";";
EnumKey:                       "enum";
                               "enum", "class";
                               "enum", "struct";
EnumBase:                      ":", TypeSpecifierSeq;
EnumeratorList:                EnumeratorDefinition, (",", EnumeratorDefinition),*;
EnumeratorDefinition:          Enumerator, ("=", ConstantExpression)?;
Enumerator:                    Identifier, AttributeSpecifierSeq?;
UsingEnumDeclaration:          "using", ElaboratedEnumSpecifier, ";";
NamespaceName:                 Identifier;
                               NamespaceAlias;
NamespaceDefinition:           NamedNamespaceDefinition;
                               UnnamedNamespaceDefinition;
                               NestedNamespaceDefinition;
NamedNamespaceDefinition:      "inline",? "namespace", AttributeSpecifierSeq,? Identifier, "{", NamespaceBody, "}";
UnnamedNamespaceDefinition:    "inline",? "namespace", AttributeSpecifierSeq,? "{", NamespaceBody, "}";
NestedNamespaceDefinition:     "namespace", EnclosingNamespaceSpecifier, "::", "inline",? Identifier, "{", NamespaceBody, "}";
EnclosingNamespaceSpecifier:   "inline",? Identifier ("::", "inline",? Identifier),*;
NamespaceBody:                 DeclarationSeq?;
NamespaceAlias:                Identifier;
NamespaceAliasDefinition:      "namespace", Identifier, "=", QualifierNamespaceSpecifier, ";";
QualifiedNamespaceSpecifier:   NestedNameSpecifier,? NamespaceName;
UsingDirective:                AttributeSpecifierSeq,? "using", "namespace", NestedNameSpecifier,? NamespaceName, ";";
UsingDeclaration:              "using", UsingDeclaratorList, ";";
UsingDeclaratorList:           UsingDeclarator, "...",? (",", UsingDeclarator, "..."?),*;
AsmDeclaration:                AttributeSpecifierSeq,? "asm", "(", StringLiteral, ")", ";";
LinkageSpecification:          "extern", StringLiteral, "{", DeclarationSeq,? "}";
                               "extern", StringLiteral, Declaration;
AttributeSpecifierSeq:         AttributeSpecifier+;
AttributeSpecifier:            "[", "[", AttributeUsingPrefix,? AttributeList, "]", "]";
                               AlignmentSpecifier;
AlignmentSpecifier:            "alignas", "(", TypeId, "...",? ")";
                               "alignas", "(", ConstantExpression, "...",? ")";
AttributeUsingPrefix:          "using", AttributeNamespace, ":";
AttributeList:                 Attribute? (",", Attribute?),*;
                               Attribute, "..." (",", Attribute),*;
Attribute:                     AttributeToken, AttributeArgumentClause?;
AttributeToken:                Identifier;
                               AttributeScopedToken;
AttributeScopedToken:          AttributeNamespace, "::", Identifier;
AttributeNamespace:            Identifier;
AttributeArgumentClause:       "(", BalancedTokenSeq,? ")";
BalancedTokenSeq:              BalancedToken+;
BalancedToken:                 "(", BalancedTokenSeq,? ")";
                               "[", BalancedTokenSeq,? "]";
                               "{", BalancedTokenSeq,? "}";
                               '[^\(\[\{\}\]\)]';

# Modules
ModuleDeclaration:       ExportKeyword,? ModuleKeyword, ModuleName, ModulePartition,? AttributeSpecifierSeq,? ";";
ModuleName:              ModuleNameQualifier,? Identifier;
ModulePartition:         ":", ModuleNameQualifier,? Identifier;
ModuleNameQualifier:     (Identifier, "."),+;
ExportDeclaration:       "export", Declaration;
                         "export", "{", DeclarationSeq,? "}";
                         ExportKeyword, ModuleImportDeclaration;
ModuleImportDeclaration: ImportKeyword, (ModuleName | ModulePartition | HeaderName), AttributeSpecifierSeq,? ";";
GlobalModuleFragment:    ModuleKeyword, ";", DeclarationSeq?;
PrivateModuleFragment:   ModuleKeyword, ":", "private", ";", DeclarationSeq?;

# Classes
ClassName:            Identifier | SimpleTemplateId;
ClassSpecifier:       ClassHead, "{", MemberSpecification,? "}";
ClassHead:            ClassKey, AttributeSpecifierSeq,? ClassHeadName, ClassVirtSpecifier,? BaseClause?;
                      ClassKey, AttributeSpecifierSeq,? BaseClause?;
ClassHeadName:        NestedNameSpecifier,? ClassName;
ClassVirtSpecifier:   "final";
ClassKey:             "class" | "struct" | "union";
MemberSpecification:  (MemberDeclaration | AccessSpecifier, ":"), MemberSpecification?;
MemberDeclaration:    AttributeSpecifierSeq,? DeclSpecifierSeq,? MemberDeclaratorList,? ";";
                      FunctionDefinition;
                      UsingDeclaration;
                      UsingEnumDeclaration;
                      Static_assertDeclaration;
                      TemplateDeclaration;
                      ExplicitSpecialization;
                      DeductionGuide;
                      AliasDeclaration;
                      OpaqueEnumDeclaration;
                      EmptyDeclaration;
MemberDeclaratorList: MemberDeclarator, (",", MemberDeclarator)*;
MemberDeclarator:     Declarator, VirtSpecifierSeq,? PureSpecifier?;
                      Declarator, RequiresClause;
                      Declarator, BraceOrEqualInitializer?;
                      Identifier,? AttributeSpecifierSeq,? ":", ConstantExpression, BraceOrEqualInitializer?;
VirtSpecifierSeq:     VirtSpecifier+;
VirtSpecifier:        "override" | "final";
PureSpecifier:        "=", "0";
ConversionFunctionId: "operator", ConversionTypeId;
ConversionTypeId:     TypeSpecifierSeq, ConversionDeclarator?;
ConversionDeclarator: PtrOperator, ConversionDeclarator?;
BaseClause:           ":", BaseSpecifierList;
BaseSpecifierList:    BaseSpecifier, "...",? (",", BaseSpecifier)*;
BaseSpecifier:        AttributeSpecifierSeq,? ClassOrDecltype;
                      AttributeSpecifierSeq,? "virtual", AccessSpecifier,? ClassOrDecltype;
                      AttributeSpecifierSeq,? AccessSpecifier, "virtual",? ClassOrDecltype;
ClassOrDecltype:      NestedNameSpecifier,? TypeName;
                      NestedNameSpecifier, "template", SimpleTemplateId;
                      DecltypeSpecifier;
AccessSpecifier:      "private" | "protected" | "public";
CtorInitializer:      ":", MemInitializerList;
MemInitializerList:   MemInitializer, "...",? (",", MemInitializer, "..."?),*;
MemInitializer:       MemInitializerId, "(", ExpressionList,? ")";
                      MemInitializerId, BracedInitList;
MemInitializerId:     ClassOrDecltype | Identifier;

# Overloading
OperatorFunctionId: "operator" Operator;
Operator:           "new" | "delete" | "new[]" | "delete[]" | "co_await" | "()" | "[]" | "->" | "->*" | "~" | "!" | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "==" | "!=" | "<" | ">" | "<=" | ">=" | "<=>" | "&&" | "||" | "<<" | ">>" | "<<=" | ">>=" | "++" | "--" | ",";
LiteralOperatorId:  "operator", StringLiteral, Identifier;
                    "operator", UserDefinedStringLiteral;

# Templates
TemplateDeclaration:            TemplateHead (Declaration | ConceptDefinition);
TemplateHead:                   "template", "<", TemplateParameterList, ">", RequiresClause?;
TemplateParameterList:          TemplateParameter, (",", TemplateParameter)*;
RequiresClause:                 "requires", ConstraintLogicalOrExpression;
ConstraintLogicalOrExpression:  ConstraintLogicalAndExpression;
                                ConstraintLogicalOrExpression, "||", ConstraintLogicalAndExpression;
ConstraintLogicalAndExpression: PrimaryExpression;
                                ConstraintLogicalAndExpression, "&&", PrimaryExpression;
TemplateParameter:              TypeParameter | ParameterDeclaration;
TypeParameter:                  TypeParameterKey, "...",? Identifier?;
                                TypeParameterKey, Identifier,? "=", TypeId;
                                TypeConstraint, "...",? Identifier?;
                                TypeConstraint, Identifier?, "=", TypeId;
                                TemplateHead, TypeParameterKey, "...",? Identifier?;
                                TemplateHead, TypeParameterKey, Identifier,? "=", IdExpression;
TypeParameterKey:               "class" | "typename";
TypeConstraint:                 NestedNameSpecifier,? ConceptName;
                                NestedNameSpecifier,? ConceptName, "<", TemplateArgumentList,? ">";
SimpleTemplateId:               TemplateName, "<", TemplateArgumentList,? ">";
TemplateId:                     SimpleTemplateId;
                                OperatorFunctionId, "<", TemplateArgumentList,? ">";
                                LiteralOperatorId, "<", TemplateArgumentList,? ">";
TemplateName:                   Identifier;
TemplateArgumentList:           TemplateArgument, "...",? (",", TemplateArgument),*;
TemplateArgument:               ConstantExpression | TypeId | IdExpression;
ConstraintExpression:           LogicalOrExpression;
DeductionGuide:                 ExplicitSpecifier,? TemplateName, "(", ParameterDeclarationClause, ")", "->", SimpleTemplateId, ";";
ConceptDefinition:              "concept", ConceptName, "=", ConstraintExpression, ";";
ConceptName:                    Identifier;
TypenameSpecifier:              "typename", NestedNameSpecifier, (Identifier | "template",? SimpleTemplateId);
ExplicitInstantiation:          "extern",? "template" Declaration;
ExplicitSpecialization:         "template", "<", ">", Declaration;

# Exception Handling
TryBlock:             "try", CompoundStatement, HandlerSeq;
FunctionTryBlock:     "try", CtorInitializer,? CompoundStatement, HandlerSeq;
HandlerSeq:           Handler+;
handler:              "catch", "(", ExceptionDeclaration, ")", CompoundStatement;
ExceptionDeclaration: AttributeSpecifierSeq,? TypeSpecifierSeq, (Declarator | AbstractDeclarator?);
                      "...";
NoexceptSpecifier:    "noexcept", ("(", ConstantExpression, ")")?;

# PreprocessingDirectives
PreprocessingFile:               Group? | ModuleFile;
ModuleFile:                      PPGlobalModuleFragment,? PPModule, Group,? PPPrivateModuleFragment?;
PPGlobalModuleFragment:          "module", ";", NewLine, Group?;
PPPrivateModuleFragment:         "module", ":", "private", ";", NewLine, Group?;
Group:                           GroupPart+;
GroupPart:                       ControlLine | IfSection | TextLine # | ConditionallySupportedDirective;
ControlLine:                     "#", "include", PPTokens, NewLine;
                                 PPImpot;
                                 "#", "define", Identifier, ReplacementList, NewLine;
                                 "#", "define", Identifier, LParen (IdentifierList? | "..." | IdentifierList, ",", "..."), ")", ReplacementList, NewLine;
                                 "#", "undef", Identifier, NewLine;
                                 "#", "line", PPTokens, NewLine;
                                 "#", "error", PPTokens,? NewLine;
                                 "#", "pragma", PPTokens,? NewLine;
                                 "#", NewLine;
IfSection:                       IfGroup, ElifGroups,? ElseGroup,? EndifLine;
IfGroup:                         "#", "if", ConstantExpression, NewLine, Group?;
                                 "#", "ifdef", Identifier, NewLine, Group?;
                                 "#", "ifndef", Identifier, NewLine, Group?;
ElifGroups:                      ElifGroup+;
ElifGroup:                       "#", "elif", ConstantExpression, NewLine, Group?;
ElseGroup:                       "#", "else", NewLine, Group?;
EndifLine:                       "#", "endif", NewLine;
TextLine:                        PPTokens,? NewLine;
ConditionallySupportedDirective: PPTokens NewLine;
LParen:                          '\((?!\s)';
IdentifierList:                  Identifier, (",", Identifier)*;
ReplacementList:                 PPTokens?;
PPTokens:                        PreprocessingToken+;
NewLine:                         "\n";
DefinedMacroExpression:          "defined", Identifier;
                                 "defined", "(", Identifier, ")";
HPreprocessingToken:             '[^>]';
HPPTokens:                       HPreprocessingToken+;
HeaderNameTokens:                StringLiteral | "<" HPPTokens ">";
HasIncludeExpression:            "__has_include", "(", (HeaderName | HeaderNameTokens), ")";
HasAttributeExpression:          "__has_cpp_attribute", "(", PPTokens, ")";
PPModule:                        "export",? "module", PPtokens,? ";", NewLine;
PPImport:                        "export",? "import", (HeaderName, PPTokens,? ";", NewLine | HeaderNameTokens, PPTokens,? ";", NewLine | PPTokens, ";", NewLine);
VaOptReplacement:                "__VA_OPT__", "(", PPTokens,? ")";